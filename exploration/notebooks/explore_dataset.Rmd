---
title: "Explore_dataset"
output: html_notebook
---

# Importo librerías y cargo datos

```{r}
library(data.table)
library(glue)
library(tidyverse)
data_external = "../../data/external/"
data_interim = "../../data/interim/"
data_processed = "../../data/processed/"
node_table = fread(paste0(data_processed,"graph_node_table.csv"), header=TRUE)
edge_table = fread(paste0(data_processed,"graph_edge_table.csv"), header=TRUE)
kg_edges = fread(paste0(data_external,"primekg_edges.csv"), header=TRUE)
kg_nodes = fread(paste0(data_external,"primekg_nodes.csv"), header=TRUE)
mondo_cui_map = fread(paste0(data_interim,"mondo_cui_map.csv")) #mapeo que armé entre CUI y MONDO
hippie = fread(paste0(data_external,"hippie_current.txt"))
signor = fread(paste0(data_interim,"signor_mapped.csv")) #signor con mapeo que hice a entrez 

setnames(
  hippie,
  old = colnames(hippie),
  new = c(
    "P1_NAME",
    "P1_ENTREZ_ID",
    "P2_NAME",
    "P2_ENTREZ_ID",
    "SCORE",
    "EVIDENCE"
  )
)
```

## Estadísticas generales del dataset

```{r echo=FALSE}
glue("El dataset tiene {dim(graph_node_table)[1]} nodos y {dim(graph_edge_table)[1]} enlaces")
cat("Número de nodos por tipo:")
table(graph_node_table$node_type)

cat("\nNodos agrupados por fuente: (conservé todos los de disgenet)")
table(graph_node_table$node_source)

cat("\nEnlaces agrupados por tipo de enlace")
table(graph_edge_table$relation)

cat("\nEnlaces agrupados por tipos de nodo: \n\n")
table(graph_edge_table[,c("a_type","b_type")])

cat("\nEnlaces agrupados por fuente: prioridad PPIs HIPPIE, es decir, saqué ppis de signor que ya estaban en hippie:")
table(graph_edge_table$source)
```

## Comparación con KG

```{r}
kg_single_disease_nodes = kg_nodes[node_type == "disease" & node_source == "MONDO"]
kg_grouped_disease_nodes = kg_nodes[node_type == "disease" & node_source == "MONDO_grouped"] #acá son grupos de ids separados por "_"
kg_single_disease_nodes = kg_single_disease_nodes[, node_id:=as.integer(node_id)] #ahora que solo tengo ids mondo que son números puedo hacer esto

num_kg_dd_edges = dim(kg_edges[relation == "disease_disease",])[1]
num_kg_group_nodes = dim(kg_grouped_disease_nodes)[1]
num_kg_disease_nodes = dim(kg_single_disease_nodes)[1]
num_total_disease_kg_nodes = dim(kg_nodes[node_type == "disease"])[1]

kg_single_disease_nodes_mapped =
  merge(x = kg_single_disease_nodes,
        y = mondo_cui_map,
        by.x = "node_id",
        by.y = "mondo",
        all.x = FALSE)[]

num_enf_mapeadas = dim(kg_single_disease_nodes_mapped)[1]
idx_grouped = kg_grouped_disease_nodes[,node_index]
num_group_edges = dim(kg_edges[relation == "disease_disease" & (x_index %in% idx_grouped | y_index %in% idx_grouped) ,])[1]
```
```{r echo=FALSE}
cat("PrimeKG tiene nodos enfermedad que son grupos obtenidos con BERT, esos no los agregué *pero podría* \n")
glue("En PrimeKG hay {num_kg_dd_edges} enlaces enfermedad-enfermedad, {num_kg_group_nodes} nodos grupo-bert y {num_kg_disease_nodes} nodos enfermedad")
glue("En el mapeo perdí {num_kg_disease_nodes - num_enf_mapeadas} nodos enfermedad porque no están en el mapeo CUI-mondo, logré mapear {num_enf_mapeadas}")
glue("Enlaces de primekg que involucraban a nodos *grupo* de enfermedades:{num_group_edges}")

```
## Self Loops

```{r echo=FALSE}
glue("Self loops: {dim(graph_edge_table[a_idx == b_idx])[1]}")
cat("Los self loops son de:\n")
table(graph_edge_table[a_idx == b_idx, source])
```

Veo quienes son estos nodos con self loops

```{r echo=FALSE}
prime_self_idx = graph_edge_table[a_idx == b_idx & source == "primekg",source_idx]
hippie_self_idx = graph_edge_table[a_idx == b_idx & source == "hippie",source_idx]
signor_self_idx = graph_edge_table[a_idx == b_idx & source == "signor",source_idx]

prime_self = kg_edges[prime_self_idx,]
hippie_self = hippie[hippie_self_idx,]
signor_self = signor[signor_self_idx,]

prime_self
hippie_self
signor_self
```

En el caso de signor y hippie esto no es llamativo, son proteínas que interactúan con sí mismas. Puedo remover estos self-loops sin problemas. En el caso de primekg tengo que ver quienes son, podría ser un problema de mapeo. 
En la tabla estoy viendo que aunque los consideré self loops, source y target tienen indices diferentes. En mondo son dos entidades diferentes pero en CUI son la misma. Podría eliminar esos self loops también.

```{r echo=FALSE}
overlapping_mondos = merge(x=prime_self,y=kg_nodes[,c("node_index","node_name")],by.x="x_index",by.y="node_index")
setnames(overlapping_mondos, old = "node_name", new = "x_name")
overlapping_mondos = merge(x=overlapping_mondos,y=kg_nodes[,c("node_index","node_name")],by.x="y_index",by.y="node_index")
setnames(overlapping_mondos, old = "node_name", new = "y_name")

overlapping_mondos
```

Exploro direccionalidad de enlaces (no me salio esto, o si pero tarda mil años)

```{r}
check_reverse = function(row){
  node1 = row[[2]]
  node2 = row[[3]]
  reversed = dim(graph_edge_table[(a_idx == node2) & (b_idx == node1),])[1]
  if (reversed != 0){
    return(row[[1]])
  }
}
```

```{r}
apply(graph_edge_table[1:1000],MARGIN=1,check_reverse)
```
